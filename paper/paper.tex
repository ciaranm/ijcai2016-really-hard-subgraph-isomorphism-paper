% vim: set spell spelllang=en tw=100 :

\documentclass[letterpaper]{article}
\usepackage[pass]{geometry}

\usepackage{ijcai13}
\usepackage{times}
\usepackage{complexity}
\usepackage{microtype}
\usepackage{gnuplot-lua-tikz}
\usepackage{amsmath}
\usepackage{amssymb}

% \usepackage{showframe}

\title{Really Hard Instances for the Subgraph Isomorphism Problem}
\author{Ciaran McCreesh\thanks{This work was supported by the Engineering and Physical Sciences
    Research Council [grant number EP/K503058/1]} \and Patrick Prossser \and James Trimble \\
University of Glasgow, Glasgow, Scotland \\
c.mccreesh.1@research.gla.ac.uk}

\begin{document}

\maketitle

\begin{abstract}
    Really hard SIP instances.
\end{abstract}

\section{Introduction}

The \emph{non-induced subgraph isomorphism problem} is to find an injective mapping from a given
pattern graph to a given target graph which preserves adjacency---in essence, we are ``finding a
copy of'' the pattern inside the target. The \emph{induced} variant of the problem additionally
requires that the mapping preserve non-adjacency, so there are no ``extra edges'' in the copy of the
pattern that we find. Despite these problems being \NP-complete, modern practical subgraph
isomorphism algorithms can handle problem instances with many hundreds of vertices in the pattern
graph, and up to ten thousand vertices in the target graph
\cite{Cordella:2004,Solnon:2010,Audemard:2014,McCreesh:2015}.

However, these algorithms cannot handle \emph{arbitrary} instances of this size. The experimental
evaluations in these papers were performed using a mix of real-world instances (from applications
??), and random graph pairs.  Using random instances can be beneficial, because it provides a way of
generating arbitrarily many instances cheaply, and reduces the risk of over-fitting when tuning
design parameters. The instances used were generated by taking a subgraph of a random (using
different models) graph and permuting the vertices.  This is not ideal: such instances are
guaranteed to be satisfiable, and so existing benchmark suites contain relatively few non-trivial
unsatisfiable instances. This can lead to bias.

Here we present a new method for creating random pattern/target pairs which can generate both
satisfiable and unsatisfiable instances. For non-induced isomorphisms, as with other hard problems,
there is a phase transition from satisfiable to unsatisfiable as we alter a parameter, and for see
the expected complexity peak occur near this phase transition when using three different solvers.

?? Some stuff in there about clique, colouring and SAT.

For induced isomorphisms, there are two phase transitions, and although instances become really hard
near each transition, there is an even harder region in between the two transitions.

?? Weakness not specific to SIP solvers, use a SAT encoding and it happens too.

\section{Non-Induced Isomorphisms}

\subsection{Varying Densities}

\subsection{Varying Sizes}

\section{Induced Isomorphisms}

\section{Other Encodings}

\begin{figure*}[tb]
    \input{gen-graph-sat.tex}
    \caption{Behaviour of other solvers on the induced variant. Each point is the average of ten
        runs. For each plot, the x-axis is the pattern density and the y-axis is the target
        density, both from 0 to 1. Along the top row, we show the proportion of instances which are
        satisfiable; the white bands shows the phase transitions. On the second row, we show the
        number of search nodes used by the Glasgow algorithm, and on the third row, the number of
        conflicts recorded by the Glucose SAT solver: the dark regions indicate ``really hard''
        instances. These results show that instances which are hard for the Glasgow algorithm tend
        to be hard using other solvers too, but do not otherwise allow comparisons between solver
        performances.}
\end{figure*}

\section{Conclusion}

\bibliographystyle{named}
\bibliography{paper}

\end{document}
